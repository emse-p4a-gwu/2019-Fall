---
title: "Week 7: Strings"
subtitle: "EMSE 6574, Section 11 "
author: "John Helveston"
date: October 07, 2019
output:
  xaringan::moon_reader:
    css: classNotes.css
---

# Announcments

If you haven't already, install the **stringr** library:
```{r eval=FALSE}
install.packages("stringr")
library(stringr)
```
```{r echo=FALSE}
library(stringr)
```

---
# Making a string

Single or double quotes - they both work:

```{r eval=FALSE}
s1 <- "This is a string"
s1
s2 <- 'I can use single quotes to include a "quote" inside a string'
s2
```

--
Use them where it makes sense, e.g.:
```{r, eval=FALSE}
cat("It's a boy!")
cat('I said, "Hi!"')
```

---
# String literals and "escaping"

Use the `\` symbol to "escape" a literal symbol:
              
--
```{r}      
cat('\"') # Double quote
```
--
```{r}
cat('\'') # Single quote
```
--
```{r}
cat('This\\that') # Backslash
```
--
```{r}
cat('This\nthat') # New line
```
--
```{r}
cat('This\tthat') #Tab space
```

---
# String constants

R has a few built-in string constants:
--
```{r}
LETTERS
letters
month.abb
month.name
```

--
The **stringr** library has some longer string constants:
```{r}
head(words)
head(sentences)
head(fruit)
```

---
# Main **stringr** functions

Most start with "`str_`":

Function        | Description                            
----------------|-----------------------------------------
`str_length()`  | number of characters                    
`str_sub()`     | extracts substrings
`str_dup()`     | duplicates characters
`str_c()`       | string concatenation   
`str_trim()`    | removes leading and trailing whitespace 
`str_pad()`     | pads a string
`str_()`        | pads a string
`str_sort()`    | sort a string alphabetically
`str_order()`   | get the order of a sorted string 
`str_split()`   | split a string into a vector
`str_detect()`  | match a string in another string 
`str_replace()` | replace a string in another string

---
# `str_length()`: Get the number of characters in a string

```{r}
str_length(" ")
str_length("hello world")
str_length("The quick brown fox jumped over the lazy dog")
```

---
# `str_sub()`: Access characters by their index

```{r}
x <- "Apple"
str_sub(x, 1, 3)
# Negative numbers count backwards from the end
str_sub(x, -3, -1)
```

--
If string is too short, it won't error:
```{r}
str_sub("App", 1, 5)
```

--
Use `str_sub()` to modify a string:
```{r}
x <- 'abcdef'
str_sub(x, 1, 3) <- 'ABC'
x
```

---
# `str_dup()`: Like `rep()` but for strings

--
```{r}
str_dup("hola", 3)
```

--
Note the difference with `rep()` (which creates a vector):
```{r}
rep("hola", 3)
```

---
# Most `stringr` functions work on string vectors

```{r}
x <- c("apples", "oranges")
x
```

--
Get the 3rd letter in each string in the vector
```{r}
str_sub(x, 3, 3)
```

--
Duplicate each string twice
```{r}
str_dup(x, 2)
```

---
# `str_c()`: Combine strings into one string

--
```{r}
str_c('x', 'y', 'z')
```

--
Use the `sep` argument to control how they're separated:
```{r}
str_c('x', 'y', 'z', sep = "-")
```

--
Note the difference with _vectors_ of strings:
```{r}
x <- c('x', 'y', 'z')
str_c(x)
```
--
To make a single string from a vector of strings, use `collapse`:
```{r}
str_c(x, collapse = '')
```

---
# Practice: Think-Pair-Share

[60 seconds](https://www.youtube.com/watch?v=CH50zuS8DD0) - no typing!

```{r}
printGreeting <- function(name, timeOfDay, isBirthday) {
    greeting <- str_c(
        "Good ", timeOfDay, " ", name,
            if (isBirthday) {
                ", and HAPPY BIRTHDAY!"
            } else {
                '.'
            }
        )
    cat(greeting)
}
```
What will this print?
```{r, eval=FALSE}
printGreeting('John', 'morning', isBirthday = FALSE)
printGreeting('John', 'morning', isBirthday = TRUE)
```
```{r, echo=FALSE}
printGreeting('John', 'morning', isBirthday = FALSE)
printGreeting('John', 'morning', isBirthday = TRUE)
```

---
# `str_trim()`: Remove excess white space

```{r}
x <- c("  a   ", "b   ",  "   c")
x
```
--
```{r}
str_trim(x) # Default trims both sides 
```
--
```{r}
str_trim(x, side = "left") # Only trim left side
```
--
```{r}
str_trim(x, side = "right") # Only trim right side
```

---
# `str_pad()`: Add white space

--
```{r}
x <- c("abc", "defghi")
x
```
--
```{r}
str_pad(x, 10) # Default pads on left
```
--
```{r}
str_pad(x, 10, side = "both") # Pad both sides
```
--
Pad with a different character:
```{r}
str_pad(x, 10, side = "both", pad = '*')
```

---
# Case conversion: `str_to_lower()`, `str_to_upper()`, `str_to_title()`

We saw these in HW 1!
```{r}
x <- "Want to hear a joke about paper? Never mind, it's tearable."
x
```
```{r}
str_to_lower(x) 
str_to_upper(x)
str_to_title(x)
```

---
# Sort string vectors alphabetically

```{r}
x <- c('Y', 'M', 'C', 'A')
x
```
--
```{r}
str_sort(x)
```
--
```{r}
str_sort(x, decreasing = TRUE)
```
--
```{r}
str_order(x)
```
--
```{r}
x[str_order(x)]
```

---
# `str_split()`: Split a string into multiple strings

--
```{r}
x <- 'This string has spaces-and-dashes'
x
```
--
```{r}
str_split(x, " ") # Split on the spaces
```
--
```{r}
str_split(x, "-") # Split on the dashes
```

---
# What's with the `[[1]]` thing?

--
`str_split()` returns a `list` of vectors
--
Example:
```{r}
x <- c('babble', 'scrabble')
str_split(x, 'bb')
```
--
If you're only splitting one string, add `[[1]]` to get the first vector:
```{r}
str_split('hooray', 'oo')[[1]]
```

---
# Common splits

--
Break a string into individual characters:
```{r}
str_split("apples", "")[[1]]
```
--
Break a sentence into individual words:
```{r}
x <- "If you want to view paradise, simply look around and view it"
str_split(x, " ")[[1]]
```














# Matching strings

## Detecting string matches

To determine if a character vector matches a pattern, use `str_detect()`. It returns a logical vector the same length as the input:

```{r}
someFruit <- fruit[1:10]
someFruit
str_detect(someFruit, "a")
```

Remember that when you use a logical vector in a numeric context, `FALSE` becomes `0` and `TRUE` becomes `1`. That makes `sum()` and `mean()` useful if you want to answer questions about matches across a vector:

```{r}
# How many words in the stringr "words" vector contain the letter "a"?
sum(str_detect(words, "a"))
# What proportion contain the letter "a"?
mean(str_detect(words, "a"))
```

## Anchors

By default, `str_detect()` will match any part of a string. But it's often useful to _anchor_ the matching condition so that it matches from the start or end of the string. You can use:

- `^` to match the _start_ of the string.
- `$` to match the _end_ of the string.

```{r}
# Which fruit start with "a"?
str_detect(someFruit, "^a")
# Which fruit end with "y"?
str_detect(someFruit, "y$")
```

To remember which is which, try this mnemonic:

> If you _start_ with power (`^`), you'll _end_ up with money (`$`).

To force a match to a complete string, anchor it with both `^` and `$`:

```{r}
x <- c("apple pie", "apple", "apple cake")
```
```{r}
str_detect(x, "apple")
str_detect(x, "^apple$")
```

In the second example above, 1 & 3 are `FALSE` because there's a space after `apple`.

## Counting matches

A variation on `str_detect()` is `str_count()`: rather than a simple yes or no, it tells you how many matches there are in a string:

```{r}
x <- c("apple", "banana", "pear")
str_count(x, "a")
```

Note that matches never overlap. For example, in `"abababa"`, how many times will the pattern `"aba"` match?

```{r}
str_count("abababa", "aba")
```

## Replacing matches

`str_replace()` and `str_replace_all()` allow you to replace matches with new strings. The simplest use is to replace a pattern with a fixed string:

```{r}
x <- c("apple", "pear", "banana")
```
```{r}
str_replace(x, "a", "-")
str_replace_all(x, "a", "-")
```

---

# Tips

Often times you'll want to break a string into it's individual letter components. To do that, use `str_split()` with the empty string `""` as the delimiter:

```{r}
s <- 'aLongStringWithLotsOfLetters'
chrs <- str_split(s, "")[[1]]
chrs
```

Once you've got all the individual characters as a vector, you can do all sorts of things:

```{r}
str_sort(chrs) # Alphabetically sort the vector
str_detect(chrs, 't') # Find where the letter "t" exists
```

If you want to count the unique occurrence of each character, you can use the `table()` function:

```{r}
table(chrs)
```




















---
# Group practice

[20 minutes](https://www.youtube.com/watch?v=kxGWsHYITAw) - In groups of 4, write the following functions:

.pull-left[
1) `reverseString(s)`

Write a function that returns the string in reverse order. So if `s` equals `"abcde"`,  `reverseString(s)` should equal `"edcba"`. You may assume that `s` only contains upper and/or lower case letters, but your solution must correctly return capital letters in their appropriate order. Here's some test cases:

- `reverseString("aWordWithCaps") == "spaChtiWdroWa"`
- `reverseString("abcde") == "edcba"`
- `reverseString("") == ""`
- `reverseString("aa") == "aa"`
]

.pull-right[
2) `isPalindrome(s)`

Write a function that returns `TRUE` if the string `s` is a [Palindrome](https://en.wikipedia.org/wiki/Palindrome) and `FALSE` otherwise. The string `s` can contains any letter, number, or symbol, but it will be a character data type. Here's some test cases:

- `isPalindrome("abcba") == TRUE`
- `isPalindrome("abcb") == FALSE`
- `isPalindrome("321123") == TRUE`

]

---
# Group practice

[20 minutes](https://www.youtube.com/watch?v=kxGWsHYITAw) - In groups of 4, write the following functions:

.pull-left[
1) `sortString(s)`

Write the function `sortString(s)` that takes a string `s` and returns back an alphabetically sorted string. So `sortString("cba")` should return `"abc"`. You may assume that `s` only contains upper and/or lower case letters. Here's some test cases:

- `sortString("cba") == "abc"`
- `sortString("abedhg") == "abdegh"`
- `sortString("AbacBc") == "aAbBcc"`

]

.pull-right[
2) `areAnagrams(s1, s2)`

**Background**: An [anagram](https://en.wikipedia.org/wiki/Anagram) is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. With that in mind, write the function `areAnagrams(s1, s2)` that takes two strings, `s1` and `s2` (that you may assume contain only upper and/or lower case letters), and returns `TRUE` if the strings are anagrams, and `FALSE` otherwise. Treat `"a"` and `"A"` as the same letters (so `"Aba"` and `"BAA"` are anagrams). Hint: you can use either `sortString(s)` or `letterCount(s)` as a helper function - each are helpful for different approaches to solving this. Here's some test cases:

- `areAnagrams("", "") == TRUE`
- `areAnagrams("abCdabCd", "abcdabcd") == TRUE`
- `areAnagrams("abcdaBcD", "AAbbcddc") == TRUE`
- `areAnagrams("abcdaabcd", "aabbcddcb") == FALSE`

]




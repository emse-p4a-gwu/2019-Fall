# -----------------------------------------------------------------------------
One's digit

# Test Cases

What should onesDigit(123) return?  Well, hopefully it's clear that it should return the number 3 (right?). So far, so good. What about onesDigit(7890)?  In this case, the ones digit is 0, so it should return 0.  Ok.  What about a single-digit number, say onesDigit(6)?  Easy enough -- just return that digit, so it should return 6.  Are there any other cases?  Yes.  What about a negative number?  What should onesDigit(-54) return?  The answer is that the sign should not matter, and it should return positive 4.

Ok, so we've thought through the test cases.  Next, we place these into an automated test function, like so:

testOnesDigit <- function() {
    cat("Testing onesDigit()... ")
    stopifnot(onesDigit(123) == 3)
    stopifnot(onesDigit(7890) == 0)
    stopifnot(onesDigit(6) == 6)
    stopifnot(onesDigit(-54) == 4)
    cat("Passed!\n")
}

See how we simply converted the test cases from the previous step into code?
    
# Stub Solution

This step is not required but is quite useful.  We'll just write a tiny version (or "stub") of our solution which does not really try to solve the problem, instead returning some bogus answer.  Why?  This lets us run our test code, at least, and watch it successfully determine that our "stub" does not actually work properly. Here is what we mean:

onesDigit <- function(x) {
    return(3)
}

testOnesDigit() # actually run the test!

But this is just what we expected!  Well, mostly.  Curiously, upon inspection we see that we passed the first test. By sheer luck, when we returned 3, we passed the test assert(onesDigit(123) == 3).  But we failed on the next test, since onesDigit(7890) should equal 0, not 3.

# Solve, Test, Repeat

So now we understand the problem statement and we have a nifty way to automatically test our solution. Great!  All that's left is to actually solve this thing.  And how do we do that?  In this case, it's actually quite simple:  the x % y is the remainder when x is divided by y, and the 1's digit is nothing more than the remainder when we divide a number by 10 (right?).  And so we get this:
    
onesDigit <- function(x) {
    return(x %% 10)  # first attempt!
}

testOnesDigit() # actually run the test!

Darn.  But at least we passed the first three tests.  So it's a start.  So it looks like we wosrk for positives and not for negatives.  Why not?  Think about how the remainder function works differently for positives and for negatives and you should (hopefully) realize our mistake.

Regardless of whether you see why, it should be easy to see what the fix is (well, at least one fix, among several options):  just take the absolute value so we're only dealing with positives!  So we get:
    
onesDigit <- function(x) {
    return(abs(x) %% 10)
}

We run this and we get:
    
    Testing onesDigit...Passed!
    
# -----------------------------------------------------------------------------
Ten's Digit

# Test Cases

tensDigit(1) should return 0.  tensDigit(23) should return 2.  tensDigit(456) should return 5.  And tensDigit(-7890) should return 9.  Is that enough test cases?  What do you think?
    
testTensDigit <- function() {
    cat("Testing tensDigit()... ")
    stopifnot(tensDigit(1) == 0)
    stopifnot(tensDigit(23) == 2)
    stopifnot(tensDigit(456) == 5)
    stopifnot(tensDigit(-7890) == 9)
    stopifnot(tensDigit(-11) == 1)
    cat("Passed!\n")
}

Stub Solution

tensDigit <- function(x) {
    return(3)
}

testTensDigit() # actually run the test!

# Solve, Test, Repeat

Say that after some thought we think (x %/% 10) might be a solution here.  So, let's try it:

tensDigit <- function(x) {
    return(x %/% 10) # our first attempt
}

testTensDigit() # actually run the test!

Darn.  But at least we passed the first two tests.  So it's a start.  At this point, we know that we failed when x = 456, in that we did not return 5, but we don't know what we did return.  That would be handy information.  So let's get it!

We'll simply print this out. Type this in:

tensDigit(456)

And we get:

45

Ahhh!  Now we see what went wrong.  We meant to only get that 5, but we got more than we bargained for!  We got all the digits except the one's digit.  So by dividing x by 10, what we really did was shift x one digit to the right.  Re-read that last sentence and think about it.

Now, after shifting to the right, the old ten's digit has become the new one's digit.  Right?  Yes!!!!  So now we have a plan to fix our code:
    
tensDigit <- function(x) {
    return(onesDigit(abs(x) %/% 10))
}
 
testTensDigit() # actually run the test!

We run this and we get:
    
    Testing tensDigit...Passed!
    
And so we've now successfully solved another problem!!!!  Hurray!!!

Not so fast!!!  What happens if we call tensDigit(-11)?  It returns 2.  Oh no!!!  What happened?  For one thing, we realize our test cases were incomplete (whoops), since they did not expose this bug.  Figure it out, and fix both our code and our test cases!

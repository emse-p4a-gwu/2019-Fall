---
title: "Functions"
output: html_document
---

```{r settings, echo=FALSE, message=FALSE, warning=FALSE}
rm(list=objects()) # start with a clean workspace
source("knitr_settings.R")
```

[Note: Some content in this page is sourced from other courses - citations are in the footnotes]^[Some content in this page is sourced from: 1) CMU [15-112: Fundamentals of Programming](http://www.kosbie.net/cmu/spring-17/15-112/), by [David Kosbie](http://www.kosbie.net/cmu/) & [Kelly Rivers](https://hcii.cmu.edu/people/kelly-rivers)]; 2) Danielle Navarro's website ["R for Psychological Science"](https://psyr.org/index.html)]

---

We already know how to use built-in functions like `sum()`, `round()`, `sqrt()`, etc. And we can access other functions by installing external packages. But many times there just isn't a function out there to do what you need. Fortunately, you can write your own!

# Basic syntax

Here's the syntax that you use to create a function:

```
FNAME <- function(ARG1, ARG2, ETC) {
  STATEMENT1
  STATEMENT2
  return(VALUE)
}
```

What this does is create a function with the name `FNAME`, which has arguments `ARG1`, `ARG2`, etc. Whenever the function is called, R executes the statements within the curly braces `{}`, and then returns the `VALUE` inside the `return()` statement. 

# Arguments

Here's a function with one argument:

```{r}
square <- function(x) {
  y <- x^2
  return(y)
}
square(2)
square(8)
```

Here's a function with multiple arguments:
 
```{r}
sumTwoValues <- function(x, y) {
  value <- x + y
  return(value)
}
sumTwoValues(2, 3)
sumTwoValues(3, 4)
```

Functions don't always have to take arguments. For example:

```{r}
doSomething <- function() {
    cat("Carpe diem!") # The cat() function prints whatever's inside it to the console
}
doSomething()
```

# The `return()` statement

Here's a basic example of using `return()` to return a value:

```{r}
isPositive <- function(x) {
    return (x > 0)
}
isPositive(5)  # TRUE
isPositive(-5) # FALSE
isPositive(0)  # FALSE
```

The `return()` statement ends the function immediately:

```{r}
isPositive <- function(x) {
    cat("Hello!")   # Runs
    return(x > 0)
    cat("Goodbye!") # Does not run ("dead code")
}
x <- isPositive(5)  # Prints Hello, then assigns TRUE to x
x
```

Notice that in the above example, the `cat("Goodbye!")` statement is ignored.

If you don't include a `return()` statement, R will return the value of the last statement by default (**Don't do this**):

```{r}
f <- function(x) {
    x + 42
}
f(5)

f <- function(x) {
    x + 42
    x + 7
}
f(5)
```

# The `cat()` statement

The `cat()` (short for "concatenating") statement prints whatever arguments it is given to the console. The arguments can be of mixed types and it will convert them all to a concatenated string:

```{r}
printX <- function(x) {
  cat("The value of x provided is", x)
}
printX(7)
printX(42)
```

Mixing up `return()` and `cat()` is a common early mistake. For example:

```{r}
cubed <- function(x) {
    cat(x^3)
}
cubed(2)   # Seems to work
2*cubed(2) # Expected 16...didn't work
```

Here's a correct version:

```{r}
cubed <- function(x) {
    return(x^3) # That's better!
}
cubed(2)   # Works!
2*cubed(2) # Works!
```

# Helper functions

It is often useful to break down more complicated problems into smaller "helper functions". These helpers can be called in other functions. Here's an example of using the helper functions `square()` and `squareRoot()` to compute the hypotenuse of a triangle:

```{r}
square <- function(x) {
   return(x^2)
}

squareRoot <- function(x) {
   return(x^0.5)
}

hypotenuse <- function(a, b) {
   return(squareRoot(square(a) + square(b)))
}

a = 3
b = 4
hypotenuse(a, b)
```

# Local variables

Any commands **inside** the function are _locally computed_. For example, if you make an assignment inside the function (like `x <- 2`), the variable `x` will **NOT** be created in the working environment. It will only be stored locally within the function.

```{r}
square <- function(x) {
  y <- x^2
  return(y)
}
y
```

Parameter and Local variable scope

def addOne(x):
    x = x + 1
    print "in addOne, x =", x
    return x

x = 5
print "first, x =", x
result = addOne(x)
print "calling addOne(x) returned:", result
print "and now x =", x

Another example / Globals (do not do this!)

def printN():
    print n   # n not local -- so it is global (bad idea!!!)

n = 5
printN()


Local variables
def minSquared(x,y):
    smaller = min(x,y)
    return smaller*smaller

print minSquared(3,4)
print minSquared(4,3)
Another example:

def isEvenPositive(x):
    isEven = ((x % 2) == 0)
    isPositive = (x > 0)
    return (isEven and isPositive)

print(isEvenPositive(-2))
print(isEvenPositive(-1))
print(isEvenPositive(0))
print(isEvenPositive(1))
print(isEvenPositive(2))

 
 












